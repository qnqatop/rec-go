// Code generated by mfd-generator v0.4.5; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type CitySearch struct {
	search

	ID        *int
	Name      *string
	IDs       []int
	NameILike *string
}

func (cs *CitySearch) Apply(query *orm.Query) *orm.Query {
	if cs == nil {
		return query
	}
	if cs.ID != nil {
		cs.where(query, Tables.City.Alias, Columns.City.ID, cs.ID)
	}
	if cs.Name != nil {
		cs.where(query, Tables.City.Alias, Columns.City.Name, cs.Name)
	}
	if len(cs.IDs) > 0 {
		Filter{Columns.City.ID, cs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if cs.NameILike != nil {
		Filter{Columns.City.Name, *cs.NameILike, SearchTypeILike, false}.Apply(query)
	}

	cs.apply(query)

	return query
}

func (cs *CitySearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if cs == nil {
			return query, nil
		}
		return cs.Apply(query), nil
	}
}

type DirectionSearch struct {
	search

	ID           *int
	UniversityID *int
	CityID       *int
	Code         *string
	Name         *string
	Cost         *int
	IDs          []int
	CodeILike    *string
	NameILike    *string
}

func (ds *DirectionSearch) Apply(query *orm.Query) *orm.Query {
	if ds == nil {
		return query
	}
	if ds.ID != nil {
		ds.where(query, Tables.Direction.Alias, Columns.Direction.ID, ds.ID)
	}
	if ds.UniversityID != nil {
		ds.where(query, Tables.Direction.Alias, Columns.Direction.UniversityID, ds.UniversityID)
	}
	if ds.CityID != nil {
		ds.where(query, Tables.Direction.Alias, Columns.Direction.CityID, ds.CityID)
	}
	if ds.Code != nil {
		ds.where(query, Tables.Direction.Alias, Columns.Direction.Code, ds.Code)
	}
	if ds.Name != nil {
		ds.where(query, Tables.Direction.Alias, Columns.Direction.Name, ds.Name)
	}
	if ds.Cost != nil {
		ds.where(query, Tables.Direction.Alias, Columns.Direction.Cost, ds.Cost)
	}
	if len(ds.IDs) > 0 {
		Filter{Columns.Direction.ID, ds.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ds.CodeILike != nil {
		Filter{Columns.Direction.Code, *ds.CodeILike, SearchTypeILike, false}.Apply(query)
	}
	if ds.NameILike != nil {
		Filter{Columns.Direction.Name, *ds.NameILike, SearchTypeILike, false}.Apply(query)
	}

	ds.apply(query)

	return query
}

func (ds *DirectionSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ds == nil {
			return query, nil
		}
		return ds.Apply(query), nil
	}
}

type DirectionsFeedbackSearch struct {
	search

	UserID       *int
	DirectionID  *int
	Rating       *float32
	UserIDs      []int
	DirectionIDs []int
}

func (dfs *DirectionsFeedbackSearch) Apply(query *orm.Query) *orm.Query {
	if dfs == nil {
		return query
	}
	if dfs.UserID != nil {
		dfs.where(query, Tables.DirectionsFeedback.Alias, Columns.DirectionsFeedback.UserID, dfs.UserID)
	}
	if dfs.DirectionID != nil {
		dfs.where(query, Tables.DirectionsFeedback.Alias, Columns.DirectionsFeedback.DirectionID, dfs.DirectionID)
	}
	if dfs.Rating != nil {
		dfs.where(query, Tables.DirectionsFeedback.Alias, Columns.DirectionsFeedback.Rating, dfs.Rating)
	}
	if len(dfs.UserIDs) > 0 {
		Filter{Columns.DirectionsFeedback.UserID, dfs.UserIDs, SearchTypeArray, false}.Apply(query)
	}
	if len(dfs.DirectionIDs) > 0 {
		Filter{Columns.DirectionsFeedback.DirectionID, dfs.DirectionIDs, SearchTypeArray, false}.Apply(query)
	}

	dfs.apply(query)

	return query
}

func (dfs *DirectionsFeedbackSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if dfs == nil {
			return query, nil
		}
		return dfs.Apply(query), nil
	}
}

type UniversityFeedbackSearch struct {
	search

	Rating       *int
	UserID       *int
	UniversityID *int
}

func (ufs *UniversityFeedbackSearch) Apply(query *orm.Query) *orm.Query {
	if ufs == nil {
		return query
	}
	if ufs.Rating != nil {
		ufs.where(query, Tables.UniversityFeedback.Alias, Columns.UniversityFeedback.Rating, ufs.Rating)
	}
	if ufs.UserID != nil {
		ufs.where(query, Tables.UniversityFeedback.Alias, Columns.UniversityFeedback.UserID, ufs.UserID)
	}
	if ufs.UniversityID != nil {
		ufs.where(query, Tables.UniversityFeedback.Alias, Columns.UniversityFeedback.UniversityID, ufs.UniversityID)
	}

	ufs.apply(query)

	return query
}

func (ufs *UniversityFeedbackSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ufs == nil {
			return query, nil
		}
		return ufs.Apply(query), nil
	}
}

type UniversytySearch struct {
	search

	ID        *int
	Name      *string
	CityID    *int
	IDs       []int
	NameILike *string
}

func (us *UniversytySearch) Apply(query *orm.Query) *orm.Query {
	if us == nil {
		return query
	}
	if us.ID != nil {
		us.where(query, Tables.Universyty.Alias, Columns.Universyty.ID, us.ID)
	}
	if us.Name != nil {
		us.where(query, Tables.Universyty.Alias, Columns.Universyty.Name, us.Name)
	}
	if us.CityID != nil {
		us.where(query, Tables.Universyty.Alias, Columns.Universyty.CityID, us.CityID)
	}
	if len(us.IDs) > 0 {
		Filter{Columns.Universyty.ID, us.IDs, SearchTypeArray, false}.Apply(query)
	}
	if us.NameILike != nil {
		Filter{Columns.Universyty.Name, *us.NameILike, SearchTypeILike, false}.Apply(query)
	}

	us.apply(query)

	return query
}

func (us *UniversytySearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if us == nil {
			return query, nil
		}
		return us.Apply(query), nil
	}
}

type UserSearch struct {
	search

	ID           *int
	CityID       *int
	UniversityID *int
	Gender       *bool
	Age          *int
	IDs          []int
}

func (us *UserSearch) Apply(query *orm.Query) *orm.Query {
	if us == nil {
		return query
	}
	if us.ID != nil {
		us.where(query, Tables.User.Alias, Columns.User.ID, us.ID)
	}
	if us.CityID != nil {
		us.where(query, Tables.User.Alias, Columns.User.CityID, us.CityID)
	}
	if us.UniversityID != nil {
		us.where(query, Tables.User.Alias, Columns.User.UniversityID, us.UniversityID)
	}
	if us.Gender != nil {
		us.where(query, Tables.User.Alias, Columns.User.Gender, us.Gender)
	}
	if us.Age != nil {
		us.where(query, Tables.User.Alias, Columns.User.Age, us.Age)
	}
	if len(us.IDs) > 0 {
		Filter{Columns.User.ID, us.IDs, SearchTypeArray, false}.Apply(query)
	}

	us.apply(query)

	return query
}

func (us *UserSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if us == nil {
			return query, nil
		}
		return us.Apply(query), nil
	}
}
